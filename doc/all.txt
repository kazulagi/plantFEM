interface CopyArray
interface ImportArray
interface ExportArray
interface ShowArray
interface ExtendArray
interface insertArray
interface removeArray
interface mean
interface distance
subroutine CopyArrayInt(a,ac)
subroutine CopyArrayRealVec(a,ac)
subroutine TrimArrayReal(a,k)
subroutine ExportArraySizeInt(Mat,RankNum,OptionalFileHandle)
subroutine ExportArrayInt(Mat,OptionalFileHandle)
subroutine ShowArrayReal(Mat,IndexArray,FileHandle,Name)
subroutine ShowArraySizeReal(Mat,OptionalFileHandle,Name)
subroutine ShowArraySizeRealThree(Mat,OptionalFileHandle,Name)
function InOrOutInt(x,xmax,xmin,DimNum) result(Inside)
subroutine ExtendArrayInt(mat,extend1stColumn,extend2ndColumn,DefaultValue)
subroutine insertArrayInt(mat,insert1stColumn,insert2ndColumn,DefaultValue,NextOf)
subroutine removeArrayInt(mat,remove1stColumn,remove2ndColumn,NextOf)
function meanVecReal(vec) result(mean_val)
function distanceReal(x,y) result(dist)
function countifSameIntArray(Array1,Array2) result(count_num)
type::Boundary_
real(8),allocatable::NBoundVal(:,:)
real(8),allocatable::TBoundElemGpVal(:,:,:)
real(8),allocatable::DBoundValInc(:,:)
real(8),allocatable::TBoundValInc(:,:)
integer,allocatable::DBoundNodID(:,:)
integer,allocatable::TBoundNodID(:,:)

integer,allocatable::NBoundNum(:)
integer,allocatable::TBoundElemNum(:)

contains
procedure :: Delete => DeallocateBoundary
procedure :: RemoveOverlap => DeleteOverlapBoundary
procedure :: ImportNBound => ImportNBound
procedure :: MergeNBound => MergeNBound

!############### Check Consistency of Objects ###############
class(Boundary_),intent(inout)::obj
integer i,j,n,m,o
if(allocated(obj%DBoundNodID))then
else
return

do i=1,size(obj%DBoundNodID,1)
if(obj%DBoundNodID(i,j)==0 )then
return
if(obj%DBoundNodID(i,j)<-1 )then
return
if(obj%DBoundNodID(i,j)/=obj%DBoundNodID(i,j) )then
return
enddo


obj%ErrorMsg=""
obj%ErrorMsg="Check Point 2/10 DBoundVal is not allocated"
endif
do i=1,size(obj%DBoundVal,1)
if(obj%DBoundVal(i,j)/=obj%DBoundVal(i,j) )then
return
enddo

obj%ErrorMsg=""
obj%ErrorMsg="Check Point 3/10 NBoundNodID is not allocated"
endif
do i=1,size(obj%NBoundNodID,1)
if(obj%NBoundNodID(i,j)==0 )then
return
if(obj%NBoundNodID(i,j)<-1 )then
return
if(obj%NBoundNodID(i,j)/=obj%NBoundNodID(i,j) )then
return
enddo

obj%ErrorMsg=""
obj%ErrorMsg="Check Point 4/10 NBoundVal is not allocated"
endif
do i=1,size(obj%DBoundVal,1)
if(obj%DBoundVal(i,j)/=obj%DBoundVal(i,j) )then
return
enddo

obj%ErrorMsg=""
obj%ErrorMsg="Check Point 5/10 DBoundNum is not allocated"
endif
if(allocated(obj%NBoundNum))then
else
return


!############### Check Consistency of Objects ###############

subroutine DeallocateBoundary(obj)

deallocate(obj%DBoundVal)
if(allocated(obj%DBoundNodID) )then
endif
deallocate(obj%NBoundVal)
if(allocated(obj%NBoundNodID) )then
endif
if(allocated(obj%DBoundNum) )then
endif
deallocate(obj%NBoundNum)
obj%ErrorMsg="All Array are deallocated."

!############### Deallocate All Objects ###############

!############### Initialize Boundary Conditions ###############
class(Boundary_),intent(inout)::obj


if(Default .eqv. .true.)then

allocate(obj%NBoundVal(1,1) )
allocate(obj%TBoundElemGpVal(1,1,1) )
allocate(obj%NBoundValInc(1,1) )
allocate(obj%DBoundNodID(1,1) )
allocate(obj%TBoundNodID(1,1) )
allocate(obj%DBoundNum(1) )
allocate(obj%TBoundNum(1) )

obj%NBoundVal(1,1)   =0.0d0
obj%TBoundElemGpVal(1,1,1)     =0.0d0
obj%NBoundValInc(1,1) = 0.0d0
obj%DBoundNodID(1,1) = 0
obj%TBoundNodID(1,1) = 0
obj%DBoundNum(1) =0
obj%TBoundNum(1) =0

endif

deallocate(obj%DBoundNum)
if(.not.allocated(obj%DBoundNodID) )then
else
endif
obj%DBoundNum(:)=0
do j=1,size(obj%DBoundNodID,2)
cycle
obj%DBoundNum(j)=obj%DBoundNum(j)+1
enddo

deallocate(obj%NBoundNum)
if(.not.allocated(obj%NBoundNodID) )then
else
endif
obj%NBoundNum(:)=0
do j=1,size(obj%NBoundNodID,2)
cycle
obj%NBoundNum(j)=obj%NBoundNum(j)+1
enddo

!############### Initialize Boundary Conditions ###############
!############### Delete Overlapped Boundary Conditions ###############
class(Boundary_),intent(inout)::obj
!only Dirichlet Boundary Condition is checked.
integer,allocatable::Intbuf(:,:)
integer :: i,j,k,n,m,countnum
n = size(obj%DBoundNodID,1)
allocate(IntBuf(n,m),RealBuf(n,m)  )
RealBuf(:,:)=   0.0d0

do i=1,size(obj%DBoundNodID,2)
do k=j+1, size(obj%DBoundNodID,1)
obj%DBoundNodID(j,i)=-1
else
endif
enddo

countnum = 0
k=0
if(obj%DBoundNodID(i,j)==-1 )then
else
endif
if(k/=m)then
IntBuf(countnum,: ) =obj%DBoundNodID(i,:)
else
endif

call TrimArray(RealBuf,countnum)
call CopyArray(RealBuf,obj%DBoundVal  )

!############### Delete Overlapped Boundary Conditions ###############

subroutine ImportDBound(obj,Node_ID,DValue)
real(8),intent(in)::DValue(:,:)


!###############  Import D-Boundary Condition ###############

!###############  Import D-Boundary Condition ###############
class(Boundary_),intent(in)::BCObj1,BCObj2
class(Boundary_),intent(inout)::OutBCObj


!###############  Import D-Boundary Condition ###############
!###############  Import N-Boundary Condition ###############
class(Boundary_),intent(in)::BCObj1,BCObj2
class(Boundary_),intent(inout)::OutBCObj
include "./MergeNBound.f90"
end subroutine MergeNBound


subroutine ImportNBound(obj,Node_ID,NValue)
real(8),intent(in)::NValue(:,:)


!###############  Import N-Boundary Condition ###############
end module BoundaryConditionClass
type :: ConstModel_
real(8),allocatable::S_IJ(:,:)
real(8),allocatable::tau(:,:)
real(8),allocatable::F_T(:,:)
real(8),allocatable::F_inv_iJ(:,:)
real(8),allocatable::Fp_iJ(:,:)
real(8),allocatable::b_ij(:,:)
real(8),allocatable::C_IJ_n(:,:)
real(8),allocatable::E_IJ(:,:)
real(8),allocatable::Cp_IJ_inv(:,:)
real(8),allocatable::Bmat(:,:)


real(8) :: lamda
real(8) :: K_mod

character*70::ModelType
end type
subroutine HyperElasticDer(obj,DerType)
end type
subroutine GetActiveNTS(obj)
subroutine getKcmat(obj,stick,StickSlip)
subroutine update_res_grad_c(j,nod_max,old_nod_coord,nts_elem_nod,active_nts&
subroutine disp_rvec(u_nod_x,u_nod_y,rvec)
subroutine get_next_segment(surface_nod,sur_nod_inf,shift,old_master,master1,master2)
subroutine load_nts_element(nts_elem_nod,nts_amo,old_nts_elem_nod,old_nts_amo,stick_slip,old_stick_slip)
subroutine setPenaltyParaCM(obj,para)
subroutine getGapCM(obj)
subroutine getForceCM(obj)
subroutine exportForceAsTractionCM(obj)
end type ControlParameter_
type ::  Page_
end type
type :: Dictionary_
contains
procedure :: Input => InputDictionary
procedure :: GetPageNum => GetPageNumDictionary


character*200 :: Path
character*200 :: FileName
end type
subroutine InitializeDictionary(obj,NumOfPage)
subroutine InputDictionary(obj,page,content)
subroutine setFilePath(obj,FilePath,FileID)
subroutine setFileName(obj,FileName,FileID)
subroutine showDictionary(obj,From,to)
function GetPageNumDictionary(obj,Content) result(page)
subroutine ImportFEMDomainDiff(obj,OptionalFileFormat,OptionalProjectName)
subroutine SetupDiffusionEq(obj)
subroutine GetDiffusionMat(obj)
subroutine GetUnknownValue(obj)
subroutine  UpdateUnknownValue(obj)
subroutine GetElemDiffusionMatrix(obj,diff_coeff,DiffMat)
subroutine GetElemMassMatrix(obj,MassMat)
type::FEMDomain_
type(Mesh_)             :: Mesh
type(Boundary_)         :: Boundary
real(8) :: RealTime
character*200 :: FileName
character*20 :: SolverType
contains
procedure,public :: Delete => DeallocateFEMDomain
procedure,public :: Import => ImportFEMDomain
procedure,public :: AddDBoundCondition => AddDBoundCondition
procedure,public :: AddTBoundCondition => AddTBoundCondition
procedure,public :: SetDataType => SetDataType
procedure,public :: SetName => SetName
procedure,public :: InitDBC => InitDBC
procedure,public :: InitTBC => InitTBC
procedure :: MeltingSkelton => MeltingSkeltonFEMDomain
procedure,public :: GmshPlotMesh => GmshPlotMesh
procedure,public :: GmshPlotContour2D => GmshPlotContour2D
procedure,public :: GnuplotExportStress => GnuplotExportStress
procedure,public :: rotate => rotateFEMDomain


type(ShapeFunction_)    :: TimeShapeFunction
end type
subroutine DeallocateFEMDomain(obj)
subroutine ExportFEMDomain(obj,OptionalFileFormat,OptionalProjectName,FileHandle,SolverType,MeshDimension)
subroutine InitDBC(obj,NumOfValPerNod)
subroutine InitNBC(obj,NumOfValPerNod)
subroutine AddNBoundCondition(obj,xmin,xmax,ymin,ymax,zmin,zmax,&
subroutine AddTBoundCondition(obj,xmin,xmax,ymin,ymax,zmin,zmax,&
subroutine SetDataType(obj,inDType)
subroutine SetUpFEMDomain(obj)
subroutine SetControlParaFEMDomain(obj,OptionalTol,OptionalItrTol,OptionalTimestep,OptionalSimMode)
subroutine MeltingSkeltonFEMDomain(obj)
subroutine GmshPlotContour(obj,gp_value,OptionalContorName,OptionalAbb,OptionalStep,Name)
subroutine GmshPlotContour2D(obj,gp_value,OptionalContorName,OptionalAbb,OptionalStep,Name)
subroutine GmshExportStress(obj,uvec,sigma,strain_measure,step,Name )
subroutine GnuplotPlotContour(obj,gp_value,OptionalContorName,OptionalAbb,OptionalStep)
subroutine moveFEMDomain(obj,x,y,z)
subroutine rotateFEMDomain(obj,x,y,z)
subroutine AddNBCFEMDomain(obj,NodID,DimID,Val,FastMode)
subroutine ExportFEMDomainAsSTL(obj,OptionalProjectName,FileHandle,SolverType,MeshDimension)
type :: FEMIface_
type(Mesh_)             :: Mesh1,Mesh2 ! Mesh[12]%ElemNod is a LOCAL node pointer, not a DIRECT pointer for each domains
type(ControlParameter_) :: ControlPara
real(8),allocatable     :: NTN_NodCoord(:,:)
real(8),allocatable     :: STS_NodCoord(:,:)
real(8),allocatable     :: NTS_Val(:,:)
integer,allocatable     :: NTN_ElemNod(:,:)
integer,allocatable     :: STS_ElemNod(:,:)
integer,allocatable     :: NTS_Active(:)
real(8),allocatable     :: NTN_Value(:,:)
real(8),allocatable     :: STS_Value(:,:)
integer,allocatable     :: GloNodPoint1(:,:),GloNodPoint2(:,:)
integer                 :: DomainID1
integer                 :: DomainID3
integer                 :: NumOfImportedDomain
character*200           :: FilePathDomain2

character*200 :: FileNameDomain2
character*9   :: Dtype

contains
procedure :: setFEMDomain => setFEMDomainFEMIface
procedure :: Import => ImportFEMIface
procedure :: Export => ExportFEMIface
procedure :: GmshPlotNTS  => GmshPlotNTSFEMIface
procedure :: GetNTSelement => GetNTSelement
procedure :: updateTimestep => updateTimestepIface
contains

subroutine InitializeFEMIface(obj,NumOfDomain)
integer,optional,intent(in)::NumOfDomain



if(allocated(obj%FEMDomains) ) deallocate(obj%FEMDomains)
allocate(obj%FEMDomains(NumOfDomain) )
allocate(obj%FEMDomains(2) )
obj%NumOfImportedDomain = 0

end subroutine

! #########################################################
class(FEMIface_),intent(inout)::obj
character(*),optional,intent(in) :: Name

if(size(obj%FEMDomains,1) < obj%NumOfImportedDomain )then
else
obj%FEMDomains(obj%NumOfImportedDomain)%FEMDomainp => dobj
if(present(Name))then
endif

! #########################################################

! #########################################################
class(FEMIface_),intent(inout)::obj
logical,optional,intent(in)::withNeumannBC,withDirichletBC

if(present(Name) )then
withNeumannBC=withNeumannBC,withDirichletBC=withDirichletBC)
call obj%FEMDomains(i)%FEMDomainp%GmshPlotMesh(Name=trim( adjustl(fstring(i)) ) ,&
endif
if(present(Name) )then
else
endif

! #########################################################

subroutine DeallocateFEMIface(obj)

if(allocated(obj%NTN_NodCoord) ) then
else

deallocate(obj%NTS_NodCoord)
if(allocated(obj%STS_NodCoord) )then
endif
deallocate(obj%NTN_ElemNod)
if(allocated(obj%NTS_ElemNod) )then
endif
deallocate(obj%STS_ElemNod)

if(allocated(obj%FEMDomains) )then
endif

! #########################################################

subroutine ImportFEMIface(obj,OptionalFileFormat,OptionalProjectName,FileHandle)
character*4,optional,intent(in)::OptionalFileFormat

character*70::ProjectName
character*9  :: DataType
real(8),allocatable::RealMat(:,:)
integer :: fh,i,j,k,NumOfDomain,n,m,DimNum,GpNum,ierr


fh=FileHandle
fh =104

FileFormat=trim(OptionalFileFormat)
FileFormat=".scf"

if(present(OptionalProjectName) )then
else
endif
obj%FileName=ProjectName

open(fh,file=FileName,status="old")
if(trim(FileFormat)==".scf" )then


return

read(fh,*) obj%FileNameDomain1
read(fh,*) obj%SolverType
endif

end subroutine


!###################### Get FEM Interfaces ##########################
class(FEMDomain_),optional,intent(inout)::obj1,obj2
integer,optional,intent(in)  ::MasterID,SlaveID
integer :: i,j,n1,ierr,err
if(.not. present(obj1) .and. .not. present(obj2) )then
return

print *, "object names #2 : ",trim(obj2%FileName)



if(err==1)then
return
n1 = index(trim(obj1%FileName),".scf", back=.true. )
obj%FilePathDomain2=trim(obj2%FilePath)
obj%FileNameDomain1=trim(obj1%FileName)
obj%FileName       ="Iface_"//obj1%FileName(1:n1-1)//"_"//trim(obj2%FileName)
call obj%GetNTNelement()

call ShowArray(obj%NTS_NodCoord,FileHandle=20)
end subroutine



!###################### Get FEM Interfaces ##########################
class(FEMIface_),intent(inout)::obj
integer,optional,intent(in) :: MasterID,SlaveID
integer :: i,j,n1,ierr,err
if(present(MasterID) )then
else
endif
if(present(SlaveID) )then
else
endif
obj1 => obj%FEMDomains(i)%FEMDomainp

print *, "object names #2 : ",trim(obj2%FileName)


call obj%GetGlobalNodePointer()
!if(err==1)then
!    return
!n1 = index(trim(obj1%FileName),".scf", back=.true. )
!obj%FilePathDomain2=trim(obj2%FilePath)
!obj%FileNameDomain1=trim(obj1%FileName)
!obj%FileName       ="Iface_"//obj1%FileName(1:n1-1)//"_"//trim(obj2%FileName)
call obj%GetNTNelement()

call ShowArray(obj%NTS_NodCoord,FileHandle=20)
end subroutine


subroutine GetNTNelement(obj)

real(8) :: dist
integer :: master,dim_num,id
node_num1=size(obj%Mesh1%NodCoord,1)

dim_num2 =size(obj%Mesh2%NodCoord,2)
if(dim_num1/=dim_num2)then
endif

allocate(xn(dim_num1) )
node_num=node_num2
else
master = 1

if(allocated(obj%NTN_ElemNod) ) deallocate(obj%NTN_ElemNod)

allocate(obj%NTN_ElemNod(node_num,2 ) ) !In terms of local IDs

if(master==1)then ! domain 1 is master >> search the pair from domain 2
id = SearchNearestCoord(obj%Mesh2%NodCoord,x)
obj%NTN_ElemNod(i,2)=id
obj%NTN_Val(i,1)=dsqrt(dot_product(x-xn,x-xn))
obj%NTN_NodCoord(i,dim_num+1:2*dim_num)=xn(:)
x(:)=obj%Mesh2%NodCoord(i,:)
obj%NTN_ElemNod(i,2)=i
xn(:)=obj%Mesh1%NodCoord(id,:)
obj%NTN_NodCoord(i,1:dim_num)=xn(:)
endif

end subroutine

!###################### Get Node-To-Segment Elements ##########################
class(FEMIface_),intent(inout)::obj
real(8),allocatable::x(:),xn(:),ElemMidPointCoord(:,:)
integer :: node_num1,dim_num1,node_num2,dim_num2,i,j,n,node_num,elem_num2,elem_num

node_num1=size(obj%Mesh1%NodCoord,1)

elem_num2=size(obj%Mesh2%ElemNod,1)

stop "ERROR :: GetNTSelement dimension of domain1 and domain2 is not consistent"
dim_num=dim_num1
elem_num=elem_num2 ! master segment
allocate(x(dim_num1) )
allocate(ElemMidPointCoord(size(obj%Mesh2%ElemNod,1),dim_num ))
xn(:)=0.0d0
xn(:)=xn(:)+1.0d0/dble(elemnod_num)*obj%Mesh2%NodCoord(obj%Mesh2%ElemNod(i,j),:  )
ElemMidPointCoord(i,:)=xn(:)

if(allocated(obj%NTS_ElemNod) ) deallocate(obj%NTS_ElemNod)
if(allocated(obj%NTS_SegmentID) ) deallocate(obj%NTS_SegmentID)

allocate(obj%NTS_ElemNod(node_num,1+elemnod_num ) ) !In terms of local IDs
allocate(obj%NTS_SegmentID(node_num,1 ) )

do i=1,node_num
id = SearchNearestCoord(ElemMidPointCoord,x)
obj%NTS_SegmentID(i,1)=id

obj%NTS_ElemNod(i,1+j)=obj%Mesh2%ElemNod(id,j)
obj%Mesh2%NodCoord( obj%Mesh2%ElemNod(id,j),:   )
obj%NTS_NodCoord(i,1:dim_num)=x(:)
enddo

end subroutine

!###################### Get Segment-To-Segment Elements ##########################
class(FEMIface_),intent(inout)::obj
print *, "now, developping"
!###################### Get Segment-To-Segment Elements ##########################

subroutine ExportFEMIface(obj,OptionalFileFormat,OptionalProjectName,FileHandle)
character*4,optional,intent(in)::OptionalFileFormat

character*70::ProjectName
character*9  :: DataType
real(8),allocatable::RealMat(:,:)
integer :: fh,i,j,k,NumOfDomain,n,m,DimNum,GpNum

if(present(FileHandle) )then
else
endif
if(present(OptionalFileFormat) )then
else
endif

ProjectName=trim(OptionalProjectName)
ProjectName="untitled"



if(trim(FileFormat)==".scf" )then

return
write(fh,'(A)') trim(obj%Dtype)
write(fh,'(A)') trim(obj%FileNameDomain2)

endif

! #########################################################


subroutine GmshPlotNTSFEMIface(obj,Name)
type(FEMDomain_) :: Fobj
character(*),optional,intent(in)::Name



print *, dim_num
n=size(obj%NTS_ElemNod,1)

if(dim_num==2)then
elemnodnum=4
! 8
else
return

allocate(Fobj%Mesh%NodCoord(n*m,dim_num) )
allocate(Fobj%Mesh%ElemMat(n) )
Fobj%Mesh%ElemMat(:)=1
Fobj%Mesh%ElemNod(:,:)=0
! create Fobj%Mesh%NodCoord
do i=1,n ! number of NTS elements

if(elemnodnum==4)then
elseif(elemnodnum==8)then
Fobj%Mesh%ElemNod(i,j+elemnodnum/2)=k
Fobj%Mesh%ElemNod(i,j-1)=k
Fobj%Mesh%ElemNod(i,j-1+elemnodnum/2)=k
endif
else
return
enddo


end subroutine


subroutine GetGlobalNodePointerNTS(obj)
type(MPI_)::mpidata
real(8),allocatable :: x(:),x_tr(:)
! get GlobalNodePointer of NTS element
NumElemIface2=size(obj%Mesh2%ElemNod,1)
m=size(obj%Mesh2%ElemNod,2)
deallocate(obj%GloNodPoint1)
if(allocated(obj%GloNodPoint2) )then
endif

do i=1,NumElemIface1
!print *, obj%Mesh1%GlobalNodID(obj%Mesh1%ElemNod(i,j) ),"/",size(obj%FEMDomains(1)%FEMDomainp%Mesh%NodCoord,1)
enddo
!
!! for Domain2
do j=1,m
obj%GloNodPoint2(i,j)=obj%Mesh2%GlobalNodID(obj%Mesh2%ElemNod(i,j) )
enddo

end subroutine

! #########################################################
class(FEMIFace_),intent(inout)::obj
integer :: dt
dt=input(default=1,option=timestep)

! #########################################################



type :: FieldObjName_
end type
type :: Field_
type(FEMIface_) ,allocatable::FEMIfaceArray(:)
Integer,allocatable::Timestep(:)
integer :: NumberOfObject,NumberOfIface
character*200 :: FolderName
character*200 :: IfaceListName
procedure :: Import => ImportField
procedure :: Export => ExportField

end type
subroutine ImportField(obj,OptionalDomainListName,OptionalIfaceListName,OptionalProjectName,OptionalFileHandle)
subroutine showField(obj)
subroutine linkDomainToIfaceField(obj)
subroutine ExportField(obj,OptionalDomainListName,OptionalIfaceListName,&
end type
subroutine SolveFiniteDeformNewton(obj,OptionItr,Solvertype)
subroutine DevideBCIntoTimestep(obj)
subroutine ImportFEMDomainFiDe(obj,OptionalFileFormat,OptionalProjectName)
subroutine SetupFiniteDeform(obj)
subroutine GetDeformStressMatAndVector(obj,OptionalStep)
subroutine GetGvec(obj,mdl,sf,gvec_e,dim_num,elemnod_num,elem)
subroutine K_mat_ICU(Kmat, elem_nod, i, Kemat)
subroutine g_vector_ICU(elem,elem_nod,gvec_e,gvec)
subroutine F_tensor_ICU(obj,elem,gauss,F_iJ_n,F_iJ)
subroutine C_tensor(F,C_IJ,b_ij,itr,dim_num)
subroutine M_neo_Hookean(C_IJ,Cp_IJ,Cp_IJ_inv,M_IJ,Lamda,mu,elem,gauss)
subroutine GetSigmaVec(Sigma,Sigma_ij,dim_num)
subroutine B_mat(dim_num,Psymat, Jmat, detJ, Bmat,mm)
subroutine SolveFiniteDeform(obj,OptionItr,Solvertype)
subroutine GetInternalVector(obj)
subroutine GetResidualVector(obj)
subroutine UpdateStrainMeasure(obj)
type Point_
contains
procedure :: set    => setPoint
end type
type Line_
contains
procedure :: setNode    => SetNodeLine
procedure :: show       => showLine

real(8) :: radius
contains
procedure :: SetCenter  => InitSetCenterCircle
procedure :: getArea    => getAreaCircle
end type
type Sphere_
real(8) :: center(3)
procedure :: Init       => InitSphere
procedure :: SetRadius  => InitSetRadiusSphere
end type
end type
type Tetragon_
end type
type Tetrahedron_
end type
type Octahedron_
end type
subroutine InitPoint(obj,dim)
subroutine showPoint(obj,Name)
subroutine SetNodeLine(obj,point,position)
subroutine InitCircle(obj,dim)
subroutine InitSetCenterCircle(obj,point)
subroutine showCircle(obj,Name)
subroutine InitSetCenterSphere(obj,point)
subroutine showSphere(obj,Name)
subroutine InitTriangle(obj,dim)
subroutine getCircleTriangle(obj,type_of_circle,circle)
subroutine gauss_seidel(a, b, x, n, itrmax, er0)
subroutine gauss_jordan_pv(a0, x, b, n)
subroutine bicgstab_nr(a, b, x, n, itrmax, er,u_nod_x, u_nod_y)
subroutine modify_residual_1(r,x, u_nod_x, u_nod_y,u_nod_dis_x,u_nod_dis_y)
subroutine modify_residual(r, u_nod_x, u_nod_y)
subroutine GPBiCG(a, b, x, n, itrmax, er)
subroutine pre_processed_GPBiCG(a, b, x, n, itrmax, er)
end type
subroutine StartMPI(obj,NumOfComm)
subroutine BarrierMPI(obj)
subroutine BcastMPIInt(obj,From,val)
subroutine BcastMPIReal(obj,From,val)
subroutine GatherMPIInt(obj,sendobj,sendcount,recvobj,recvcount,&
subroutine ScatterMPIReal(obj,sendobj,sendcount,recvobj,recvcount,&
subroutine AlltoAllMPIInt(obj,sendobj,sendcount,recvobj,recvcount,&
subroutine AlltoAllMPIReal(obj,sendobj,sendcount,recvobj,recvcount,&
subroutine ReduceMPIInt(obj,sendobj,recvobj,count,start,To,&
subroutine showLapTimeMPI(obj,clength,rank)
subroutine CopyMPI(obj,OriginComm,NewCommLayerID)
end type MaterialProp_
subroutine DeallocateMaterialProp(obj)
subroutine MergeMaterialProp(inobj1,inobj2,outobj)
subroutine ShowMatPara(obj)
function norm(vec) result(a)
function SearchNearestCoord(Array,x)  result(id)
function SearchIDIntVec(Vec,val) result(id_)
function cross_product(a,b) result (c)
subroutine calcgz(x2,x11,x12,nod_coord,gzi)
subroutine trans_rank_2(A,A_T)
subroutine inverse_rank_2(A,A_inv)
function GetNormMatRe(a) result(b)
function fstring_int_len(x,length) result(a)
function fstring_real_len(x,length) result(a)
function freal(ch)	result(a)
function input_Int(default,option) result(val)
function input_Real(default,option) result(val)
function input_IntArray(default,option) result(val)
function input_RealArray(default,option) result(val)
function input_logical(default,option) result(val)
function zeroif_Int(val,negative,positive) result(retval)
function zeroif_Real(val,negative,positive) result(retval)
subroutine removeWord_String(str,keyword,itr,Compare)
subroutine CopyMesh(cobj,obj,Minimum)
subroutine ImportElemMat(obj,elem_mat)
subroutine GetFacetElement(obj)
subroutine GetInterface(obj1,obj2,iface1,iface2,err)
subroutine GetInterfaceElemNod(obj,iface)
subroutine ExportNodCoord(obj,nod_coord)
subroutine ExportSurface2D(obj,surface_nod)
subroutine SortFacetMesh(obj)
subroutine MeshingMesh(obj,Mode,itr_tol)
subroutine getCircumscribedCircleMesh(obj,centerx,centery,centerz,radius)
subroutine getCircumscribedTriangleMesh(obj,triangle)
subroutine DelauneygetNewNodeMesh(obj,node_id,staged_node,triangle)
subroutine DelauneygetNewTriangleMesh(obj,triangle_node_id,new_node_id)
subroutine removeCircumscribedTriangleMesh(obj)
subroutine EnforceMassConserv(difobj,defobj)
type :: MultiPhysics_
type(FEMDomain_),pointer :: FEMDomain1
contains
end type
subroutine SyncMesh(obj,Arrow)
subroutine omp_matmul(a,b,mm)
type :: PreProcessing_
character*200   :: PictureName
integer         :: PixcelSize(2),num_of_pixcel
contains
procedure :: ImportPictureName  => ImportPictureName
procedure :: ShowName           => ShowPictureName
procedure :: GetPixcelSize      => GetPixcelSize
procedure :: SetColor           => SetColor
procedure :: GetPixcelByRGB     => GetPixcelByRGB
procedure :: AssembleSurfaceElement => AssembleSurfaceElement
procedure :: ExportGeoFile      => ExportGeoFile
procedure :: ConvertGeo2Inp     => ConvertGeo2Inp
procedure :: ConvertMsh2Scf     => ConvertMsh2Scf
procedure :: Export             => ExportPreProcessing
procedure :: SetDataType        => SetDataTypeFEMDomain
procedure :: SetUp              => SetUpPreprocessing
procedure :: SetBC              => SetBoundaryConditionPrePro
procedure :: SetMatPara         => SetMatParaPreProcessing
procedure :: ShowBC             => ShowBCPrePrecessing
procedure :: Convert2Dto3D      => Convert2Dto3D
procedure :: getSkelton         => getSkeltonPreProcessing
procedure :: setEntity          => setEntityPreProcessing
procedure :: meshing            => meshingPreProcessing


subroutine InitializePrePro(obj,Default)
logical,optional,intent(in)::Default
call obj%FEMDomain%Init(Default)
! #########################################################

subroutine ImportPictureName(obj,Name)
character(*),intent(in)::Name
end subroutine

subroutine ShowPictureName(obj)
print *, trim(obj%PictureName)
! #########################################################

subroutine ShowPixcelSize(obj)
character *20       :: pix_x
write(pix_x,*) obj%PixcelSize(1)

trim(adjustl(pix_y) )
! #########################################################

! #########################################################
class(PreProcessing_),intent(inout):: obj
character(*),optional,intent(in)   :: Name
character *200      :: python_script
character *200      :: command

write(pid,*) MPIData%MyRank
python_buffer="GetPixcelSize_pid_"//trim(adjustl(pid))//".txt"
python_script=Name//"GetPixcelSize_pid_"//trim(adjustl(pid))//".py"


!print *, trim(python_script)
! using python script
fh=MPIData%MyRank+10
command = "from PIL import Image"
command = "import sys"
command = "import os"

command = 'img_in = Image.open("'//trim(obj%PictureName)//'")'
command = 'python_buffer = open("'//trim(python_buffer)//'","w")'

command = "rgb_im = img_in.convert('RGB')"
command = "size = rgb_im.size"
command = "print( str(size[0]), ' ',str(size[1])  ) "

command = "python_buffer.write( str(size[0]))"
command = "python_buffer.write('\n')"
command = "python_buffer.write( str(size[1]))"

command = "img_in.close()"
command = "python_buffer.close()"
close(fh)
command = "python3 "//trim(python_script)
call system(trim(command))
! get pixcel size
read(fh,*) obj%PixcelSize(1)
close(fh)

! #########################################################

subroutine GetAllPointCloud(obj,MPIData,Name)
class(MPI_),intent(inout)          :: MPIData
character *20       :: pid
character *200      :: python_buffer
integer              :: fh
call MPIData%GetInfo()

python_buffer="GetAllPointCloud_pid_"//trim(adjustl(pid))//".txt"
python_script=Name//"GetAllPointCloud_pid_"//trim(adjustl(pid))//".py"
endif
print *, trim(python_script)
! using python script
fh=MPIData%MyRank+10
command = "from PIL import Image"
command = "import sys"
command = "import os"

command = 'img_in = Image.open("'//trim(obj%PictureName)//'")'
command = 'python_buffer = open("'//trim(python_buffer)//'","w")'

command = "rgb_im = img_in.convert('RGB')"
command = "size = rgb_im.size"
command = "print( str(size[0]), ' ',str(size[1])  ) "

command = "width,height =img_in.size"
command = "for i in range(width):"
command = "for j in range(height):"
command = "R,G,B=rgb_im.getpixel((i,j))"
command = "python_buffer.write(str(i)+'\t')"
command = "python_buffer.write(str(j)+'\t')"
command = "python_buffer.write(str(R)+'\t')"
command = "python_buffer.write(str(G)+'\t')"
command = "python_buffer.write(str(B)+'\n')"

command = "img_in.close()"
command = "python_buffer.close()"
close(fh)
command = "python3 "//trim(python_script)
call system(trim(command))
end subroutine

subroutine GetPixcelByRGB(obj,MPIData,err,onlycoord,Name)
class(MPI_),intent(inout)          :: MPIData
logical,optional,intent(in)        :: onlycoord
character *20       :: pid
character *20       :: er
character *200      :: python_buffer
character *200      :: command

error=err
error=0

write(pid,*) MPIData%MyRank
write(Green,*) obj%ColorRGB(2)
write(er,*) error
python_script="GetPixcelByRGB_pid_"//trim(adjustl(pid))//".py"
python_buffer_size="GetPixcelByRGB_size_pid_"//trim(adjustl(pid))//".txt"
if(present(Name) )then
python_buffer       =Name//"GetPixcelByRGB_pid_"//trim(adjustl(pid))//".txt"
endif

! python imaging library is to be installed.
open(fh,file=trim(python_script),status="replace")
write(fh,'(A)') adjustl(trim(command))
write(fh,'(A)') adjustl(trim(command))
write(fh,'(A)') adjustl(trim(command))
! open file
write(fh,'(A)') adjustl(trim(command))
write(fh,'(A)') adjustl(trim(command))
write(fh,'(A)') adjustl(trim(command))
! get pixcel size
write(fh,'(A)') adjustl(trim(command))
write(fh,'(A)') adjustl(trim(command))
write(fh,'(A)') adjustl(trim(command))
! get rgb pixcel coordinates
command = "itr = 0"

write(fh,'(A)') adjustl(trim(command))
write(fh,'(A)') adjustl(trim(command))
write(fh,'(A)') "   "//adjustl(trim(command))
write(fh,'(A)') "       "//adjustl(trim(command))
")+abs(G-"//adjustl(trim(Green))//&
write(fh,'(A)') "       "//adjustl(trim(command))
write(fh,'(A)') "       "//adjustl(trim(command))
command = "python_buffer.write(str(i)+'\t')"
command = "itr=itr+1"
if( onlycoord .eqv. .true. )then
write(fh,'(A)') "           "//adjustl(trim(command))
command = "python_buffer.write(str(j)+'\t')"
command = "python_buffer.write(str(R)+'\t')"
command = "python_buffer.write(str(G)+'\t')"
command = "python_buffer.write(str(B)+'\n')"
endif
! close
write(fh,'(A)') adjustl(trim(command))
write(fh,'(A)') adjustl(trim(command))
write(fh,'(A)') adjustl(trim(command))
write(fh,'(A)') adjustl(trim(command))

print *, trim(command)

open(fh,file=python_buffer_size,status="old")
close(fh)
allocate(obj%FEMDomain%Mesh%NodCoord(sizeofpc,3) )
open(fh,file=python_buffer,status="old")
read(fh,*)obj%FEMDomain%Mesh%NodCoord(i,1:2)
obj%FEMDomain%Mesh%NodCoord(i,2)=-1.0d0*obj%FEMDomain%Mesh%NodCoord(i,2)

end subroutine

! #########################################################
class(PreProcessing_),intent(inout):: obj

obj%ColorRGB(2)=Green

! #########################################################
! #########################################################
class(PreProcessing_),intent(inout):: obj
print *, "Object Name is : ",trim(obj%PictureName)
print *, "Green : ",obj%ColorRGB(2)

! #########################################################

subroutine GetPixcelSurfaceNode(obj,MPIData,r,NumOfMaxNod,Name)
class(MPI_),intent(inout)          :: MPIData
integer,optional,intent(in)        :: r,NumOfMaxNod
character*20    :: pid
integer,allocatable :: KilledPixcel(:)
real(8) :: x_real,y_real,z_real
real(8),allocatable :: buffer(:,:)
if(present(r) )then
else
endif
if(present(NumOfMaxNod) )then
else
endif
n=size(obj%FEMDomain%Mesh%NodCoord,1)
KilledPixcel(:)=0
! remove isolated pixcel and surrounded nodes
point_count=0

x_real=obj%FEMDomain%Mesh%NodCoord(i,1)
z_real=obj%FEMDomain%Mesh%NodCoord(i,3)
y_real_tr=obj%FEMDomain%Mesh%NodCoord(j,2)

(y_real-y_real_tr)*(y_real-y_real_tr)+&


if(diff_real < max_r)then
endif
if(point_count > MaxNod )then
exit
enddo
KilledPixcel(i)=1
enddo

call MPIData%GetInfo()
fh=MPIData%MyRank+10
if(present(Name) )then
endif
open(fh,file=python_buffer,status="replace")
if(KilledPixcel(i)==0 )then
else
endif
close(fh)
do i=1,n
enddo
point_count=0
if(KilledPixcel(i)==0)then
buffer(point_count,:)=obj%FEMDomain%Mesh%NodCoord(i,:)
cycle
enddo
allocate(obj%FEMDomain%Mesh%NodCoord(size(buffer,1),size(buffer,2) ) )


end subroutine


subroutine AssembleSurfaceElement(obj,MPIData,dim,threshold,DelRange,Name)
class(MPI_),intent(inout)          :: MPIData
character(*),optional,intent(in)   :: Name
character*20    :: pid
integer,allocatable     :: checked(:)
integer :: i,j,k,n,trial_num,id_tr,fh,r_threshold,drange
if(present(threshold) )then
else
endif
if(present(DelRange) )then
else
endif
if( present(dim) .and. dim/=2 )then
stop   "AssembleSurfaceElement :: >> only 2-D is available."

allocate(buffer(n,3))
allocate(checked(n),r_value(n) )

checked(1)=1
do i=1,n-1
trial_num=0
if(checked(j)==1 )then
endif
x(:)   =buffer(i,:)
r_tr=dsqrt(dot_product(x-x_tr,x-x_tr ) )
r_ref=r_tr
else
id_tr=j
else
endif
enddo
checked(id_tr)=1

! remove unnatural pixcel
do i=1,size(buffer,1)-1
x_tr(:)=buffer(i+1,:)
if(r_tr > dble(r_threshold))then
do k=1,drange
checked(i+k)=1
if(i-k >= 1)then
endif
enddo
endif

deallocate(obj%FEMDomain%Mesh%NodCoord)

do i=1,n
cycle
k=k+1

enddo
obj%FEMDomain%Mesh%NodCoord(:,:)=buffer(:,:)


write(pid,*) MPIData%MyRank
python_buffer="GetSurface_pid_"//trim(adjustl(pid))//".txt"
python_buffer=Name//"GetSurface_pid_"//trim(adjustl(pid))//".txt"

do i=1,size(obj%FEMDomain%Mesh%NodCoord,1)
enddo

! #########################################################

! #########################################################
class(PreProcessing_),intent(inout):: obj
character(*),optional,intent(in)    :: Name
character*200   :: python_buffer
real(8),allocatable:: buffer(:,:)
integer :: i,j,k,n,m,fh
n=size(obj%FEMDomain%Mesh%NodCoord,1)
allocate(selected(n) )
k=0
k=k+1
selected(i)=1
else
endif


do i=1,n
k=k+1
endif


obj%FEMDomain%Mesh%NodCoord(:,:)=buffer(:,:)

write(pid,*) MPIData%MyRank
python_buffer="GetSurface_pid_"//trim(adjustl(pid))//".txt"
if(present(Name) )then
endif
do i=1,size(obj%FEMDomain%Mesh%NodCoord,1)
enddo

end subroutine


subroutine ExportGeoFile(obj,MPIData,Name)
character(*),optional,intent(in)    :: Name
character*200   :: python_buffer
integer :: i,j,k,n,fh,xsize

fh=MPIData%MyRank+10

python_buffer=Name//"GetSurface_pid_"//trim(adjustl(pid))//".geo"
endif
xsize = size(obj%FEMDomain%Mesh%NodCoord,1)
do i=1,xsize
x_p=obj%FEMDomain%Mesh%NodCoord(i,1)
write(fh,*)"Point(",i,") = {",x_p,",",y_p,",","0, 1.0};"

do i=2,xsize
enddo
do i=1,xsize-1
enddo
write(fh,*)"Plane Surface(",xsize+2,") = {",xsize+1,"};"
close(fh)
!print *, "Generating mesh..."
end subroutine


subroutine ConvertGeo2Msh(obj,MPIData,Name)
class(MPI_),intent(inout)          :: MPIData
character*200   :: python_buffer
character*20    :: pid


python_buffer=" "
python_buffer="GetSurface_pid_"//trim(adjustl(pid))//".geo"
python_buffer=Name//"GetSurface_pid_"//trim(adjustl(pid))//".geo"
command="gmsh "//trim(python_buffer)//" -2 -algo del2d -clmin 100"
writE(*,'(A)') trim(command)
call system(command)
!call system("sh ./MakeMesh.sh")

end subroutine

! #########################################################
class(PreProcessing_),intent(inout):: obj
character(*),optional,intent(in)    :: Name
character*200   :: command
integer :: i,j,k,n,fh
write(pid,*) MPIData%MyRank
fh=MPIData%MyRank+10
command  = " "
if(present(Name) )then
endif


!call system("sh ./MakeMesh.sh")

end subroutine

subroutine ConvertGeo2Mesh(obj,MPIData,SizePara,Name)
class(MPI_),intent(inout)          :: MPIData
character(*),optional,intent(in)    :: Name
character*200   :: command
integer :: i,j,k,n,fh,sp

if(present(SizePara) )then
else
endif

write(pid,*) MPIData%MyRank
fh=MPIData%MyRank+10
command  = " "
if(present(Name) )then
endif





end subroutine

subroutine ConvertMsh2Scf(obj,MPIData,ElementType,Name)
class(MPI_),intent(inout)          :: MPIData
character*200   :: command,infile,outfile
character(*),optional,intent(in)    :: Name
character*11 MeshFormat
character*6  Nodes
character*12  EndElements
integer :: i,j,k,n,n1,n2,fh,a,nm,mm,nod_num,nn,elem_num,surf_num
real(8) :: re1,re2

! deallocate all
deallocate(obj%FEMDomain%Mesh%NodCoord)

deallocate(obj%FEMDomain%Mesh%ElemNod)
! ======================================================

! ======================================================
fh=MPIData%MyRank+10
outfile = "GetSurface_pid_"//trim(adjustl(pid))//".scf"
if(present(Name) )then
outfile = Name//"GetSurface_pid_"//trim(adjustl(pid))//".scf"

print *, "Opening ",trim(infile)

!read file to get nod and elem number
read(fh,*)re1,nm,mm
read(fh,*)Nodes
if(nodes == "$Entit")then
read(fh,*)nodes
print *, "Read entities"
endif
else
endif
! ======================================================
read(fh,*)nod_num
if(allocated(obj%FEMDomain%Mesh%NodCoord))then
endif
do i=1,nod_num
if(i/=a)then
endif
read(fh,*)EndNodes
if(EndNodes/="$EndNodes")then
endif

! ======================================================
if(Elements/="$Elements")then
endif
read(fh,*)elem_num
if(trim(ElementType)=="LinearRectangularGp4")then
elseif(trim(ElementType)=="LinearHexahedralGp8")then
else
return
else
elemnod_num=4

k=0
read(fh,*)n1,n2,n3
if(startfrom==0)then
endif
endif
allocate(obj%FEMDomain%Mesh%ElemNod(k,elemnod_num) )

if(EndElements/="$EndElements")then
endif
! ========================================================

write(pid,*) MPIData%MyRank
infile="GetSurface_pid_"//trim(adjustl(pid))//".msh"
if(present(Name) )then
infile  = Name//"GetSurface_pid_"//trim(adjustl(pid))//".msh"



open(fh,file=infile,status="old")
! ======================================================
! ======================================================
read(fh,*)MeshFormat
read(fh,*)EndMeshFormat
if(nodes/="$Nodes")then
endif
! ======================================================
read(fh,*)nod_num
if(allocated(obj%FEMDomain%Mesh%NodCoord))then
endif
do i=1,nod_num
enddo

stop  "ERROR: invalid location:$EndNodes"
! ======================================================

read(fh,*)Elements
stop  "ERROR: invalid location: $Elements"

if(present(ElementType) )then
elemnod_num=  4
elemnod_num= 8
print *, "PreProcessingClass.f90  >> Element : ",ElementType,"is not defined."
endif
! default
endif
k=0
if(startfrom > i )then
cycle

k=k+1
cycle

read(fh,*) n1
enddo
read(fh,*)EndElements
stop  "ERROR: invalid location: $EndElements"
close(fh)
! ========================================================

! Setup FEMDomain
end subroutine





subroutine ConvertMesh2Scf(obj,MPIData,ElementType,Name)
class(MPI_),intent(inout)          :: MPIData
character*200   :: python_buffer
character*200,optional,intent(in) :: ElementType
character*11 MeshFormat
character*6  Nodes
character*12  EndElements
integer :: i,j,k,n,n1,n2,fh,a,nm,mm,nod_num,nn,elem_num,surf_num,l
real(8) :: re1,re2

! ======================================================
if(allocated(obj%FEMDomain%Mesh%NodCoord ))then
endif
if(allocated(  obj%FEMDomain%Mesh%ElemNod ))then
endif


write(pid,*) MPIData%MyRank
infile="GetSurface_pid_"//trim(adjustl(pid))//".mesh"
if(present(Name) )then
outfile = Name//"GetSurface_pid_"//trim(adjustl(pid))//".scf"
endif
open(fh,file=infile,status="old")
! ======================================================
! ======================================================
read(fh,*)MeshFormat
read(fh,*)mm

! Number of nodes
!print *,"nod_number",nod_num
deallocate(obj%FEMDomain%Mesh%NodCoord)
allocate(obj%FEMDomain%Mesh%NodCoord(nod_num,3) )
do i=1,nod_num
enddo
read(fh,*)EndNodes
! ======================================================
read(fh,*)mm
read(fh,*) elem_num
read(fh,*)EndNodes


read(fh,*)mm
devide_line(:,:)=-1
do i=1,mm
triangle(i,4)=-1
read(fh,*)EndNodes
! ======================================================

obj%FEMDomain%Mesh%ElemNod(:,:)=-1
read(fh,*) obj%FEMDomain%Mesh%ElemNod(i,1:4)
! ======================================================


deallocate(obj%FEMDomain%Mesh%ElemMat)
allocate(obj%FEMDomain%Mesh%ElemMat(elem_num))
! ======================================================
! convert triangle
do j=1,3
node1=triangle(i,1)
elseif(i==2)then
node2=triangle(i,3)
node1=triangle(i,3)
endif
do l=1,size(obj%FEMDomain%Mesh%ElemNod,2)
tr1=obj%FEMDomain%Mesh%ElemNod(k, 1)
elseif(l==2)then
tr2=obj%FEMDomain%Mesh%ElemNod(k, 3)
tr1=obj%FEMDomain%Mesh%ElemNod(k, 3)
elseif(l==4)then
tr2=obj%FEMDomain%Mesh%ElemNod(k, 1)
stop "ERROR :: ConvertMesh2Scf"
if(node2==tr1 .and. node1 == tr2)then
endif
enddo
enddo
!call ShowArray(obj%FEMDomain%Mesh%NodCoord,triangle(:,1:3),20)
!do i=1,size(devide_line,1)
!enddo


! #########################################################





subroutine ExportPreProcessing(obj,MPIData,FileName,MeshDimension,Name)
class(MPI_),optional,intent(inout) :: MPIData
character(*),optional,intent(in)   :: Name
character*200   :: python_buffer
character*20    :: pid

if(present(MPIData) )then
fh=MPIData%MyRank+120
python_buffer=Name//"GetSurface_pid_"//trim(adjustl(pid))
python_buffer="GetSurface_pid_"//trim(adjustl(pid))
endif
if(present(Name) )then
else
endif
if(present(Name) )then
else
endif


! #########################################################

subroutine SetSolverPreProcessing(obj,inSolverType)
character*200,optional,intent(in) :: inSolverType

sn = inSolverType
sn = "Default"



!##################################################

!##################################################
class(PreProcessing_),intent(inout)::obj
character*200 :: sn
sn=""
if( .not.present(inDType) )then
else
endif
call obj%FEMDomain%SetDataType(trim(sn) )
end subroutine
!##################################################

subroutine SetUpPreprocessing(obj,DataType,SolverType,NoFacetMode,MatPara)
character*200,optional,intent(in) :: DataType
logical,optional,intent(in) :: NoFacetMode
real(8),allocatable::MatParaDef(:,:)

if(present(DataType) )then
else
endif
call obj%FEMDomain%Mesh%Init(NoFacetMode=NoFacetMode)
allocate(MatParaDef(1,1) )
call obj%FEMDomain%MaterialProp%Init(MaterialParameters=MatParaDef)
call obj%FEMDomain%MaterialProp%Init(MaterialParameters=MatPara)

end subroutine

!##################################################
,picscalex,picscaley,picscalez)
real(8),optional,intent(in)::scalex,scaley,scalez
real(8) :: lx,ly,lz

if(scalex == 0.0d0)then
return
lx=maxval(obj%FEMDomain%Mesh%NodCoord(:,1) ) -&
if(lx==0.0d0)then
endif
obj%FEMDomain%Mesh%NodCoord(:,1)/lx*scalex
endif
if(present(scaley) )then
stop "ERROR :: SetScalePreProcessing >> scaley==0.0d0"
else
minval(obj%FEMDomain%Mesh%NodCoord(:,2) )
stop "ERROR :: SetScalePreProcessing >> ly==0.0d0"
obj%FEMDomain%Mesh%NodCoord(:,2)=&
endif
if(present(scalez) )then
stop "ERROR :: SetScalePreProcessing >> scalez==0.0d0"
else
minval(obj%FEMDomain%Mesh%NodCoord(:,3) )
stop "ERROR :: SetScalePreProcessing >> lz==0.0d0"
obj%FEMDomain%Mesh%NodCoord(:,3)=&
endif

write(123,*) obj%FEMDomain%Mesh%NodCoord(i,:)

!##################################################

!##################################################
tmin,tmax,val,val_id,NumOfValPerNod)
real(8),optional,intent(in)::xmin,xmax
real(8),optional,intent(in)::zmin,zmax
logical,optional,intent(in)::Dirichlet,Neumann,Initial
real(8),optional,intent(in)::val
if(present(Dirichlet) )then

,zmin=zmin,zmax=zmax,tmin=tmin,tmax=tmax,val=val,val_id=val_id,NumOfValPerNod=NumOfValPerNod)

endif
if(present(Neumann) )then

,zmin=zmin,zmax=zmax,tmin=tmin,tmax=tmax,val=val,val_id=val_id,NumOfValPerNod=NumOfValPerNod)
return
endif
if(present(Initial) )then

,zmin=zmin,zmax=zmax,tmin=tmin,tmax=tmax,val=val,val_id=val_id,NumOfValPerNod=NumOfValPerNod)
return
endif
end subroutine

subroutine SetSizeOfBCPrePrecessing(obj,Dirichlet,Neumann,Initial,NumOfValue)

integer,optional,intent(in)::NumOfValue
integer :: coord_dim
if(.not. present(Dirichlet) )then
else
endif
if(.not. present(Neumann) )then
else
endif

IC = .false.
IC=Initial

if(DB .eqv. .true.)then
elseif(NB .eqv. .true.)then
elseif(IC .eqv. .true.)then
else
endif

!##################################################
!##################################################
class(PreProcessing_),intent(inout)::obj
logical,optional,intent(in)::Dirichlet,Neumann,Initial
integer :: n,m1,m2,i
if(Dirichlet .eqv. .true.)then
m1=size(obj%FEMDomain%Boundary%DBoundNodID,1)
print *, "Number of boundary conditions are :: ", n
do i=1,m1
enddo
print *, obj%FEMDomain%Boundary%DBoundVal(i,:)



!##################################################

!##################################################
class(PreProcessing_),intent(inout)::obj
integer :: i,n,m
n=size(obj%FEMDomain%Mesh%NodCoord,1)


buffer(i,1:2)=obj%FEMDomain%Mesh%NodCoord(i,1:2)
deallocate(obj%FEMDomain%Mesh%NodCoord)
obj%FEMDomain%Mesh%NodCoord(:,:)=buffer(:,:)
end subroutine

!##################################################
class(PreProcessing_),intent(inout)::obj
real(8),optional,intent(in)::Thickness
real(8) :: Tn

! only for linear elements
if(present(Thickness))then
print *, "ERROR :: Convert2Dto3D >> Thickness = 0"
else
endif
Tn=1.0d0

if(division==0)then
return
NumOfLayer=division
NumOfLayer=1

n=size(obj%FEMDomain%Mesh%NodCoord,1)


do i=1,n
buffer( n*(j-1) + i ,3)   = Tn / dble(NumOfLayer)*dble(j-1)
enddo
deallocate(obj%FEMDomain%Mesh%NodCoord)
obj%FEMDomain%Mesh%NodCoord(:,:)=buffer(:,:)

! ElemNod
if(.not.allocated(obj%FEMDomain%Mesh%ElemNod) )then
return
n=size(obj%FEMDomain%Mesh%ElemNod,1)


do i=1,n
buffer( n*(j-1)+i, m+1:2*m  ) = obj%FEMDomain%Mesh%ElemNod(i,1:m)+numnod*(j)
enddo
deallocate(obj%FEMDomain%Mesh%ElemNod)
obj%FEMDomain%Mesh%ElemNod(:,:)=buffer(:,:)


print *, "Caution :: Convert2Dto3D >> ElemMat is not allocated = 0"
endif
allocate(buffer(n*NumOfLayer,1))
do j=1,NumOfLayer
buffer( n*(j-1)+i, 1      ) = obj%FEMDomain%Mesh%ElemMat(i)
enddo
deallocate(obj%FEMDomain%Mesh%ElemMat)
obj%FEMDomain%Mesh%ElemMat(:)=buffer(:,1)


!##################################################
!##################################################
class(PreProcessing_),intent(inout)::obj
integer,optional,intent(in)::OptionalSimMode,OptionalItrTol,OptionalTimestep
call SetControlPara(obj%FEMDomain%ControlPara,OptionalTol,OptionalItrTol,OptionalTimestep,OptionalSimMode)
!##################################################
!##################################################
class(PreProcessing_),intent(inout)::obj
real(8),optional,intent(in)::Val,AllVal(:)

if(.not.allocated(obj%FEMDomain%MaterialProp%MatPara) )then
obj%FEMDomain%MaterialProp%MatPara(1,1)=0.0d0

if(NumOfMaterial > size(obj%FEMDomain%MaterialProp%MatPara,1) )then
do i=1,NumOfMaterial - mm

if(present(val) )then
endif
n=size(obj%FEMDomain%MaterialProp%MatPara,2)
if(present(AllVal) )then
p(1)=n
obj%FEMDomain%MaterialProp%MatPara(mm+i,1: minval(p) )=AllVal(1: minval(p) )

endif

if(present(NumOfPara) )then
mm=size(obj%FEMDomain%MaterialProp%MatPara,2)

if(present(val) )then
endif
if(present(AllVal) )then
p(1)=n
obj%FEMDomain%MaterialProp%MatPara(1: minval(p) , mm+i)=AllVal(1: minval(p) )
enddo
endif

!##################################################

subroutine SetMatIDPreProcessing(obj,xmin,xmax,ymin,ymax,zmin,zmax,&
class(PreProcessing_),intent(inout)::obj
real(8),optional,intent(in)::ymin,ymax
real(8),optional,intent(in)::tmin,tmax
integer :: i,j,n
! Now implementing
,zmin=zmin,zmax=zmax,tmin=tmin,tmax=tmax,MaterialID=MaterialID)

!##################################################

!##################################################
class(PreProcessing_),intent(inout)::obj
call obj%FEMDomain%MeltingSkelton()
end subroutine

!##################################################
Radius,XSize,YSize,ZSize,Xloc,Yloc,Zloc)
logical,optional,intent(in) :: Circle,Rectangle,Plane,Cylinder,Box
integer :: i

if(Circle .eqv. .true.)then
return
endif
if( present(Rectangle) )then
if(.not. present(Xsize) )then
return
if(.not. present(Ysize) )then
return

deallocate(obj%FEMDomain%Mesh%NodCoord)
if(allocated(obj%FEMDomain%Mesh%ElemNod) )then
endif
deallocate(obj%FEMDomain%Mesh%ElemMat)
allocate(obj%FEMDomain%Mesh%NodCoord(4,2) )
obj%FEMDomain%Mesh%NodCoord(2,1)=Xsize; obj%FEMDomain%Mesh%NodCoord(2,2)=0.0d0
obj%FEMDomain%Mesh%NodCoord(4,1)=0.0d0; obj%FEMDomain%Mesh%NodCoord(4,2)=ysize
allocate(obj%FEMDomain%Mesh%ElemNod(1,4) )
obj%FEMDomain%Mesh%ElemNod(1,i)=i
allocate(obj%FEMDomain%Mesh%ElemMat(1) )

if( present(Xloc) )then
endif
obj%FEMDomain%Mesh%NodCoord(:,2)=obj%FEMDomain%Mesh%NodCoord(:,2)+Yloc
return
endif
if( present(Plane) )then
print *, "Under construction"
endif
if( present(Cylinder) )then
print *, "Under construction"
endif
if( present(Box) )then
if(.not. present(Xsize) )then
return
if(.not. present(Ysize) )then
return
if(.not. present(Zsize) )then
return

deallocate(obj%FEMDomain%Mesh%NodCoord)
if(allocated(obj%FEMDomain%Mesh%ElemNod) )then
endif
deallocate(obj%FEMDomain%Mesh%ElemMat)

obj%FEMDomain%Mesh%NodCoord(1,1)=0.0d0; obj%FEMDomain%Mesh%NodCoord(1,2)=0.0d0; obj%FEMDomain%Mesh%NodCoord(1,3)=0.0d0;
obj%FEMDomain%Mesh%NodCoord(3,1)=Xsize; obj%FEMDomain%Mesh%NodCoord(3,2)=ysize; obj%FEMDomain%Mesh%NodCoord(3,3)=0.0d0;
obj%FEMDomain%Mesh%NodCoord(5,1)=0.0d0; obj%FEMDomain%Mesh%NodCoord(5,2)=0.0d0; obj%FEMDomain%Mesh%NodCoord(5,3)=ZSize;
obj%FEMDomain%Mesh%NodCoord(7,1)=Xsize; obj%FEMDomain%Mesh%NodCoord(7,2)=ysize; obj%FEMDomain%Mesh%NodCoord(7,3)=ZSize;


obj%FEMDomain%Mesh%ElemNod(1,2)=2
obj%FEMDomain%Mesh%ElemNod(1,4)=4
obj%FEMDomain%Mesh%ElemNod(1,6)=6
obj%FEMDomain%Mesh%ElemNod(1,8)=8

obj%FEMDomain%Mesh%ElemMat(1)=1
if( present(Xloc) )then
endif
obj%FEMDomain%Mesh%NodCoord(:,2)=obj%FEMDomain%Mesh%NodCoord(:,2)+Yloc
if( present(Zloc) )then
endif

endif


!##################################################

subroutine BooleanModifyerPreProcessing(obj,ModObj,XDiv,Ydic,Zdiv)
class(PreProcessing_),intent(inout)::ModObj
real(8) :: ground_level
integer :: ground_surface_id,n,m,itr,k,i,j,buf(2)
integer,allocatable::RSIElemID(:),RSINodeID(:),RSIElemNod(:,:),AvailFE(:)

if(.not.allocated(obj%FEMDomain%Mesh%NodCoord) )then
return
if(.not.allocated(Modobj%FEMDomain%Mesh%NodCoord) )then
return

! if rectangle => ok
! ### only structural is supported ###
xmin=minval(obj%FEMDomain%Mesh%NodCoord(:,1) )
ymin=minval(obj%FEMDomain%Mesh%NodCoord(:,2) )
ground_level=maxval(obj%FEMDomain%Mesh%NodCoord(:,2) )

DimNum=size(obj%FEMDomain%Mesh%NodCoord,2)
ElemNodNum=size(obj%FEMDomain%Mesh%ElemNod,2)
allocate(OldNodID(NodeNum),OldtoNewNodID(NodeNum))
OldtoNewNodID(:)=0
RSINodeID(:)=-1
call GetSurface(ModObj%FEMDomain%Mesh)

! call showArray(-Obj%FEMDomain%Mesh%NodCoord,Obj%FEMDomain%Mesh%FacetElemNod,FileHandle=224)

n=size(ModObj%FEMDomain%Mesh%FacetElemNod,1)
allocate(AvailFE(n) )
countnode(:,:)=0
itr=0
do j=1,m
! utilize
countnode(ModObj%FEMDomain%Mesh%FacetElemNod(i,j),2)=i
itr=itr+1
endif
enddo
k=0
if(k==0 .and. AvailFE(i)==1 )then
endif
if(k==0 .and. AvailFE(i)==0)then
k=1
if(k==1 .and. AvailFE(i)==0)then
endif
endnode=i
endif
enddo

buf(2)=endnode
m=size(Obj%FEMDomain%Mesh%NodCoord,2)

itr=0

exit
if(AvailFE(i)==1 )then
NodCoord(itr,:)=Obj%FEMDomain%Mesh%NodCoord(Obj%FEMDomain%Mesh%FacetElemNod(i,1) ,: )

enddo
NodCoord(1+itr,1)=xmax        ;NodCoord(1+itr,2)=ymax       ;
NodCoord(3+itr,1)=xmin        ;NodCoord(3+itr,2)=ymin       ;
itr=itr+4



cycle

itr=itr+1
endif
if(itr > n)then
endif

allocate(Obj%FEMDomain%Mesh%NodCoord(size(NodCoord,1),size(NodCoord,2) ) )
Obj%FEMDomain%Mesh%NodCoord(i,:)=NodCoord(i,:)


!call showArray(NodCoord,FileHandle=226)
!print *, startnode,endnode


deallocate(obj%FEMDomain%Mesh%ElemNod)


itr=0
if(AvailFE(i)==1 )then
obj%FEMDomain%Mesh%FacetElemNod(itr,:)=Modobj%FEMDomain%Mesh%FacetElemNod(i,:)
OldNodID( Modobj%FEMDomain%Mesh%FacetElemNod(i,j)  )=1
endif

! list up old to new
itr=0
if(OldNodID(i)==1 )then
OldtoNewNodID(i)=itr
enddo
do i=1,size(obj%FEMDomain%Mesh%FacetElemNod,1)
obj%FEMDomain%Mesh%FacetElemNod(i,j)=OldtoNewNodID( obj%FEMDomain%Mesh%FacetElemNod(i,j)  )
stop "BooleanModifyerPreProcessing :: ERROR :: OldtoNewNodID is wrong "
enddo


if(allocated(obj%FEMDomain%Mesh%NodCoord) )then
endif
itr=0
if( OldNodID(i)==1 )then
obj%FEMDomain%Mesh%NodCoord(itr,:)=Modobj%FEMDomain%Mesh%NodCoord(i,:)
enddo
countnode(:,:)=0

! Find edge of SurfaceNod
itr=0
do j=1,size(obj%FEMDomain%Mesh%FacetElemNod,2)
countnode(obj%FEMDomain%Mesh%FacetElemNod(i,j),1 )+1
if(k<j)then
endif
enddo

if(maxval(countnode(:,1) )==3 )then
stop
print *, "Boolean >> ERROR :: minval(countnode)==2 "
else
stop

do i=1,size(countnode,1)
itr=itr+1
startnode=i
endnode=i
stop "Boolean >> ERROR :: countnode(i,2) /= (1 or 2) "
endif

print *,"Boolean >> ERROR :: itr /= 2"
endif
! SurfaceNod
do i=1, size(obj%FEMDomain%Mesh%FacetElemNod,1)
write(1233,*) obj%FEMDomain%Mesh%NodCoord(i,:)

enddo





!do i=1,NodeNum
!        RSINodeID(i)=1
!enddo
!itr=0
!    do j=1,ElemNodNum
!            RSIElemID(:)=-1
!            exit
!    enddo
!allocate(RSIElemNod(ElemNum-itr,ElemNodNum) )
!    if(RSIElemNod(i) == 1 )then
!    endif


else
return

elseif(size(obj%FEMDomain%Mesh%NodCoord,2)==3)then
if(size(obj%FEMDomain%Mesh%ElemNod) == 8)then

else
return
else
return


!##################################################
subroutine ReversePreProcessing(obj)

end subroutine


!##################################################
class(PreProcessing_),intent(inout)::obj
integer,optional,intent(in):: Step
integer :: stp

stp=step
stp=0


!##################################################

subroutine meshingPreProcessing(obj)

end subroutine

subroutine importPixcelAsNodePreProcessing(obj,interval)
integer,optional,intent(in):: interval
real(8),allocatable :: random(:)
!integer :: fh1,fh2,xsize,ysize,final_size,interval_,i,j,k,xpixcel,ypixcel
m=size(obj%FEMDomain%Mesh%NodCoord,1)
k=size(obj%FEMDomain%Mesh%NodCoord,1)
call random_number(random)


NewNodCoord(i,1:2)=obj%FEMDomain%Mesh%NodCoord(int(random(i) ),1:2)
deallocate(obj%FEMDomain%Mesh%NodCoord)
obj%FEMDomain%Mesh%NodCoord(:,:)=NewNodCoord(:,:)
return
!    open(fh1,file=trim(obj%PixcelSizeDataName),status="old" )
!    read(fh1,*) xsize
!    close(fh1)
!    fh2=10
!    if(allocated(obj%FEMDomain%Mesh%NodCoord) )then
!    endif
!    final_size=xsize*ysize/interval_-1
!    k=1
!    do i=1,xsize*ysize
!        if(j>final_size)then
!        endif
!        obj%FEMDomain%Mesh%NodCoord(j,1)=dble(xpixcel)
!        k=k+1
!            k=1
!        endif
!    close(fh2)

!##################################################
end module

type::Random_
integer,allocatable  :: random_int_seed(:)
real(8) :: random_real
contains
procedure :: random     => getRandom
procedure :: choiceInt  => choiceRandomInt
!procedure :: choiceString => choiceRandomString
procedure :: save       => saveRandom



subroutine initRandom(obj)
!integer,optional,intent(in)::SeedSize

allocate(obj%random_int_seed(SeedSize) )
call random_seed(get=obj%random_int_seed)
end subroutine

!##########################################
class(Random_)::obj


!##########################################

!##########################################
class(Random_),intent(inout)::obj
call random_seed(put=obj%random_int_seed)
!##########################################
!##########################################
class(Random_),intent(in)::obj
real(8),intent(in) :: From,To
val(1)=From
diff=abs(from-to)
x=a*diff+minval(val)
end function

!##########################################
class(Random_),intent(in)::obj
integer :: x

val(2)=To

xr=a*diff+minval(val)
if(x==From-1)then
endif
x=To

!##########################################
!##########################################
class(Random_),intent(in)::obj
integer,Optional,intent(in) :: Array(:,:)

if(present(Vector) )then
val=Vector(posi)
endif
if(present(Array ))then
posi =obj%randint(1,size(Array,1) )
val=Array(posi,posi2)
endif
print *, "No list is imported."

!##########################################

function choiceRandomReal(obj,Vector,Array) result(val)
real(8),Optional,intent(in) :: Vector(:)
real(8) :: val

if(present(Vector) )then
val=Vector(posi)
endif
if(present(Array ))then
posi =obj%randint(1,size(Array,1) )
val=Array(posi,posi2)
endif
print *, "No list is imported."
end function

!##########################################
!    class(Random_),intent(in) :: obj
!    character(1) :: val
!
!
!    posi=obj%randint(1,length )
!
!end function

end module
end type ShapeFunction_
subroutine DeallocateShapeFunction(obj)
subroutine GetGaussPoint(obj)
subroutine SetGaussPoint(obj)
subroutine GetShapeFunction(obj)
subroutine GetShapeFuncDer1(obj)
subroutine GetShapeFuncDer2(obj)
subroutine GetElemCoord(obj,nod_coord,elem_nod,elem_id)
subroutine Simulator(world,OptionalStep,OptionalTime)
subroutine DisplaySimulation(sim,field,step)
subroutine SetSimulatorTime(sim,field,time)
type :: SpaceTimeFEM_
real(8),allocatable ::DeformStress(:,:,:)
real(8),allocatable ::DeformStressInit(:,:,:)
real(8),allocatable ::DeformStressRHS(:,:)
real(8),allocatable ::DeformVecEBEInc(:,:)
real(8),allocatable ::DeformVecGloTot(:)

real(8),allocatable ::ResidualVecGlo(:)

real(8)             ::dt,error

contains
procedure :: Init       => Init
procedure :: SetRHS     => SetRHS


! ############################################################
class(SpaceTimeFEM_),intent(inout)  :: obj


! ############################################################

subroutine Init(obj)


! ############################################################

! ############################################################
class(SpaceTimeFEM_),intent(inout)  :: obj
end subroutine


subroutine GetSTShapeFunc(obj,ElemID,GpID)
integer,optional,intent(in)::ElemID

call obj%STFEMDomain%ShapeFunction%GetAll(elem_id=ElemID,nod_coord=obj%STFEMDomain%Mesh%NodCoord,&
call obj%STFEMDomain%TimeShapeFunction%GetAll(elem_id=ElemID,nod_coord=obj%STFEMDomain%Mesh%NodCoord,&
elseif(obj%MeshMove .eqv. .true.)then
elem_nod=obj%STFEMDomain%Mesh%ElemNod,OptionalGpID=GpID)
elem_nod=obj%STFEMDomain%Mesh%ElemNod,OptionalGpID=GpID)
stop "ERROR :: SetElementMatrix >> please run constructor obj%Init to create instance"

! ############################################################

subroutine SetElementMatrix(obj)

end subroutine

! ############################################################
class(ShapeFunction_),intent(inout)  :: Nobj,Tobj
end subroutine



! ############################################################
class(SpaceTimeFEM_),intent(inout)  :: obj

! ############################################################
end module
## Class Name :: 

### Instruction:


*     
type :: Term_
character*70 :: gmsh

character*70 :: GaussJordan
character*70 :: Result
contains
end type
subroutine InitializeTerm(obj)
type :: Nodep_
end type
type :: Node_
type(Nodep_),allocatable :: Child(:)
real(8)         :: vector(3)
double precision:: fpval
integer         :: ID
procedure,public :: Init => InitializeNode
end type
subroutine InitializeTree(obj,NumOfNode)
subroutine AddNodeInTree(obj,NodeObj)
subroutine cutNodeInTree(obj,NodeObj)
subroutine showTree(obj)
function countIfParentIDis(obj,ParentID) result(num)
function parentNodeIDTree(obj,ParentID) result(NodeID)
subroutine setVisualMapTree(obj)
ArrayOperationClass     
BoundaryConditionClass     
ConstitutiveModelClass  
ContactMechanicsClass   
ControlParameterClass   
DictionaryClass         
DiffusionEquationClass  
FEMDomainClass          
FEMIfaceClass           
FieldClass              
FiniteDeformationClass  
GeometryClass           
LinearSolverClass       
MPIClass                
MainClass               
MaterialPropClass     
MathClass             
MeshOperationClass    
MultiDiffDeformClass  
MultiPhysicsClass     
OpenMPClass           
PostProcessingClass
PreProcessingClass
RandomClass
ShapeFunctionClass
SiCroFClass
SimulatorClass
SpaceTimeDeformClass
TermClass
TreeClass